function next_crosshair() {
  var isBricks = window.location.href.includes("brickspreview");
  document.querySelectorAll(".nb-crosshair").forEach((container) => {
    if (isBricks && container.getAttribute("data-disable-builder") === "1") {
      return;
    }
    const lineH = container.querySelector(".nb-crosshair__line-horizontal");
    const lineV = container.querySelector(".nb-crosshair__line-vertical");
    const lerp = (a, b, n) => (1 - n) * a + n * b;
    let mouse = { x: 0, y: 0 };
    const renderedStyles = {
      tx: {
        previous: 0,
        current: 0,
        amt: parseFloat(container.getAttribute("data-crosshair-attach")),
      },
      ty: {
        previous: 0,
        current: 0,
        amt: parseFloat(container.getAttribute("data-crosshair-attach")),
      },
    };
    gsap.set([lineH, lineV], { opacity: 0 });
    const getMousePos = (e, container) => {
      const bounds = container.getBoundingClientRect();
      return { x: e.clientX - bounds.left, y: e.clientY - bounds.top };
    };
    const render = () => {
      renderedStyles.tx.current = mouse.x;
      renderedStyles.ty.current = mouse.y;
      for (const key in renderedStyles) {
        renderedStyles[key].previous = lerp(
          renderedStyles[key].previous,
          renderedStyles[key].current,
          renderedStyles[key].amt
        );
      }
      gsap.set(lineV, { x: renderedStyles.tx.previous });
      gsap.set(lineH, { y: renderedStyles.ty.previous });
      requestAnimationFrame(render);
    };
    container.addEventListener("mousemove", (e) => {
      mouse = getMousePos(e, container);
      const bounds = container.getBoundingClientRect();
      if (
        e.clientX < bounds.left ||
        e.clientX > bounds.right ||
        e.clientY < bounds.top ||
        e.clientY > bounds.bottom
      ) {
        gsap.to([lineH, lineV], { opacity: 0 });
      } else {
        gsap.to([lineH, lineV], { opacity: 1 });
      }
    });
    container.addEventListener(
      "mousemove",
      () => {
        renderedStyles.tx.previous = renderedStyles.tx.current = mouse.x;
        renderedStyles.ty.previous = renderedStyles.ty.current = mouse.y;
        gsap.to([lineH, lineV], { opacity: 1 });
        requestAnimationFrame(render);
      },
      { once: !0 }
    );
    container.querySelectorAll("a").forEach((link) => {
      link.addEventListener("mouseenter", () => tl.restart());
      link.addEventListener("mouseleave", () => tl.progress(1).kill());
    });
  });
}
document.addEventListener("DOMContentLoaded", function (t) {
  bricksIsFrontend && next_crosshair();
});
