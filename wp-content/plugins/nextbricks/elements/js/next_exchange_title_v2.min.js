function next_exchange_title_v2() {
  class ExchangeTitleV2 {
    constructor(options = {}) {
      this.settings = options;
      Object.assign(this.settings);
      this.currentWordIndex = 0;
      this.wordContainer = this.settings.wordElement;
      this.animatedContainer = this.settings.containerElement;
      this.init();
    }
    getWordWidth(word) {
      const temp = document.createElement("div");
      temp.style.position = "absolute";
      temp.style.visibility = "hidden";
      temp.style.whiteSpace = "nowrap";
      const styles = window.getComputedStyle(this.wordContainer);
      temp.style.fontSize = styles.fontSize;
      temp.style.fontFamily = styles.fontFamily;
      temp.style.fontWeight = styles.fontWeight;
      temp.style.letterSpacing = styles.letterSpacing;
      temp.textContent = word;
      document.body.appendChild(temp);
      const width = temp.offsetWidth;
      document.body.removeChild(temp);
      return width;
    }
    getHorizontalPadding() {
      const styles = getComputedStyle(this.animatedContainer);
      const paddingLeft = parseInt(styles.getPropertyValue("--padding-left"));
      const paddingRight = parseInt(styles.getPropertyValue("--padding-right"));
      return paddingLeft + paddingRight;
    }
    getVerticalPadding() {
      const styles = getComputedStyle(this.animatedContainer);
      const paddingTop = parseInt(styles.getPropertyValue("--padding-top"));
      const paddingBottom = parseInt(
        styles.getPropertyValue("--padding-bottom")
      );
      return paddingTop + paddingBottom;
    }
    getWordHeight() {
      const temp = document.createElement("div");
      temp.style.position = "absolute";
      temp.style.visibility = "hidden";
      const styles = window.getComputedStyle(this.wordContainer);
      temp.style.fontSize = styles.fontSize;
      temp.style.fontFamily = styles.fontFamily;
      temp.style.fontWeight = styles.fontWeight;
      temp.style.lineHeight = styles.lineHeight;
      temp.textContent = "Xy";
      document.body.appendChild(temp);
      const height = temp.offsetHeight;
      document.body.removeChild(temp);
      return height;
    }
    animateWord(word) {
      const horizontalPadding = this.getHorizontalPadding();
      const verticalPadding = this.getVerticalPadding();
      const nextWidth = this.getWordWidth(word) + horizontalPadding;
      const nextHeight = this.getWordHeight() + verticalPadding;
      this.wordContainer.textContent = word;
      let splitText = new SplitText(this.wordContainer, { type: "chars" });
      gsap.set(splitText.chars, { y: 50, opacity: 0 });
      const { containerAnimation, letterAnimation } = this.settings;
      gsap.to(this.animatedContainer, {
        width: nextWidth,
        height: nextHeight,
        duration: containerAnimation.duration,
        ease: containerAnimation.ease,
      });
      gsap.to(splitText.chars, {
        duration: letterAnimation.duration,
        y: 0,
        opacity: 1,
        stagger: letterAnimation.stagger,
        ease: letterAnimation.ease,
        delay: containerAnimation.duration / 2,
        onComplete: () => {
          gsap.to(splitText.chars, {
            duration: letterAnimation.duration,
            y: this.settings.letterAnimation.y,
            opacity: this.settings.letterAnimation.opacity,
            stagger: letterAnimation.stagger,
            ease: this.settings.letterAnimation.ease,
            delay: this.settings.displayDuration,
            onComplete: () => {
              splitText.revert();
              this.currentWordIndex =
                (this.currentWordIndex + 1) % this.settings.words.length;
              this.animateWord(this.settings.words[this.currentWordIndex]);
            },
          });
        },
      });
    }
    init() {
      const initialPadding = this.getHorizontalPadding();
      const initialVerticalPadding = this.getVerticalPadding();
      this.animatedContainer.style.width =
        this.getWordWidth(this.settings.words[0]) + initialPadding + "px";
      this.animatedContainer.style.height =
        this.getWordHeight() + initialVerticalPadding + "px";
      this.wordContainer.textContent = this.settings.words[0];
      this.animateWord(this.settings.words[0]);
    }
  }
  var isBricks = window.location.href.includes("brickspreview");
  document
    .querySelectorAll(".next-exchange-title-v2")
    .forEach((titleElement) => {
      if (
        isBricks &&
        titleElement.getAttribute("data-disable-builder") === "1"
      ) {
        const containerElement = titleElement.querySelector(
          ".next-exchange-title-v2__animated-container"
        );
        const wordElement = titleElement.querySelector(
          ".next-exchange-title-v2__word"
        );
        const words = titleElement
          .getAttribute("data-lines")
          .split("next11")
          .filter((word) => word !== "");
        wordElement.textContent = words[0];
        const temp = new ExchangeTitleV2({
          words,
          containerElement,
          wordElement,
        });
        const horizontalPadding = temp.getHorizontalPadding();
        const verticalPadding = temp.getVerticalPadding();
        containerElement.style.width =
          temp.getWordWidth(words[0]) + horizontalPadding + "px";
        containerElement.style.height =
          temp.getWordHeight() + verticalPadding + "px";
        return;
      }
      const words = titleElement
        .getAttribute("data-lines")
        .split("next11")
        .filter((word) => word !== "");
      var boxDuration = parseFloat(
        titleElement.getAttribute("data-box-duration")
      );
      var boxEase = titleElement.getAttribute("data-box-ease");
      var lineDuration = parseFloat(
        titleElement.getAttribute("data-line-duration")
      );
      var letterAltitude = titleElement.getAttribute("data-letter-altitude");
      var letterEase = titleElement.getAttribute("data-letter-ease");
      var letterDuration = parseFloat(
        titleElement.getAttribute("data-letter-duration")
      );
      var letterStagger = parseFloat(
        titleElement.getAttribute("data-letter-stagger")
      );
      new ExchangeTitleV2({
        words: words,
        containerElement: titleElement.querySelector(
          ".next-exchange-title-v2__animated-container"
        ),
        wordElement: titleElement.querySelector(
          ".next-exchange-title-v2__word"
        ),
        containerAnimation: { duration: boxDuration, ease: boxEase },
        letterAnimation: {
          y: "-100%",
          opacity: 0,
          duration: letterDuration,
          ease: letterEase,
          stagger: letterStagger,
        },
        displayDuration: lineDuration,
      });
    });
}
document.addEventListener("DOMContentLoaded", function (t) {
  document.fonts.ready.then(function () {
    bricksIsFrontend && next_exchange_title_v2();
  });
});
