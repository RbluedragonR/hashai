function next_countdown() {
  var isBricks = window.location.href.includes("brickspreview");
  document.querySelectorAll(".nb-countdown").forEach((countdownElement) => {
    countdownElement.removeAttribute("data-flickering");
    const updateHeights = () => {
      requestAnimationFrame(() => {
        const digitContainers = countdownElement.querySelectorAll(
          ".nb-countdown__digit-container"
        );
        digitContainers.forEach((dc) => {
          const height = dc.getBoundingClientRect().height;
          dc.style.height = `${height}px`;
        });
      });
    };
    updateHeights();
    window.addEventListener("resize", updateHeights);
    (function () {
      const animation = {
        countdown: countdownElement,
        setupSessionEndDate: function () {
          const sessionKey = this.countdown.dataset.sessionEndDate;
          const LOCALSTORAGE_KEY = `countdownEndDate_${sessionKey}`;
          const storedEndDate = localStorage.getItem(LOCALSTORAGE_KEY);
          if (!storedEndDate) {
            const durationStr = this.countdown.dataset.sessionEndDate;
            const [days, hours, minutes, seconds] = durationStr
              .split(":")
              .map(Number);
            const totalSeconds =
              days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60 + seconds;
            const endDateTime = new Date().getTime() + totalSeconds * 1000;
            localStorage.setItem(LOCALSTORAGE_KEY, endDateTime.toString());
            return endDateTime;
          }
          return parseInt(storedEndDate, 10);
        },
        updateDigit: function (digitElements, newValue, oldValue) {
          if (newValue === oldValue) return;
          const timeline = gsap.timeline();
          digitElements.next.innerHTML = newValue;
          digitElements.next.style.top = "-100%";
          digitElements.next.style.opacity = parseFloat(
            this.countdown.dataset.fadeFrom
          );
          timeline
            .to(
              digitElements.current,
              parseFloat(this.countdown.dataset.unitsDuration),
              {
                top: "100%",
                opacity: parseFloat(this.countdown.dataset.fadeFrom),
                ease: this.countdown.dataset.unitsAnimationEase,
              }
            )
            .to(
              digitElements.next,
              parseFloat(this.countdown.dataset.unitsDuration),
              {
                top: "0%",
                opacity: 1,
                ease: this.countdown.dataset.unitsAnimationEase,
              },
              this.countdown.dataset.unitsDelay
            )
            .call(() => {
              digitElements.current.innerHTML = newValue;
              digitElements.current.style.top = "0";
              digitElements.current.style.opacity = "1";
              digitElements.next.innerHTML = "";
            });
        },
        animate: function () {
          const units = ["days", "hours", "minutes", "seconds"];
          const unitsContainer = {};
          const countdownType = this.countdown.dataset.countdownType || "date";
          let targetDateUTC;
          if (countdownType === "session") {
            targetDateUTC = new Date(this.setupSessionEndDate());
          } else {
            const sourceTimezone = this.countdown.dataset.timezone;
            const targetDateStr = this.countdown.dataset.endDate;
            const dateMatches = targetDateStr.match(/\d{4}-\d{2}-\d{2}/g) || [];
            const timeMatches = targetDateStr.match(/\d{2}:\d{2}/g) || [];
            const latestDate = dateMatches[dateMatches.length - 1];
            const latestTime = timeMatches[timeMatches.length - 1];
            const finalDateStr = `${latestDate} ${latestTime}`;
            targetDateUTC = new Date(
              new Date(finalDateStr).toLocaleString("en-US", {
                timeZone: sourceTimezone,
              })
            );
            try {
              Intl.DateTimeFormat(undefined, { timeZone: sourceTimezone });
            } catch (e) {
              console.error("Invalid timezone:", sourceTimezone);
              return;
            }
          }
          const updateCountdown = () => {
            const now = new Date();
            let totalSeconds = Math.floor((targetDateUTC - now) / 1000);
            if (totalSeconds < 0) {
              const customJs = this.countdown.dataset.customJs;
              if (customJs) {
                try {
                  eval(customJs);
                } catch (error) {
                  console.error(
                    "Error executing JS when Countdown ended:",
                    error
                  );
                }
              }
              units.forEach((unit) => {
                unitsContainer[unit].digits.forEach((dc) => {
                  dc.current.innerHTML = "0";
                  dc.current.style.top = "0";
                  dc.current.style.opacity = "1";
                  dc.next.innerHTML = "";
                });
              });
              return;
            }
            const values = {
              days: Math.floor(totalSeconds / (24 * 60 * 60)),
              hours: Math.floor((totalSeconds % (24 * 60 * 60)) / (60 * 60)),
              minutes: Math.floor((totalSeconds % (60 * 60)) / 60),
              seconds: totalSeconds % 60,
            };
            Object.keys(unitsContainer).forEach((unit) => {
              const newValue = String(values[unit]).padStart(2, "0");
              const oldValue = String(previousValues[unit]).padStart(2, "0");
              if (previousValues[unit] === -1) {
                unitsContainer[unit].digits.forEach((dc, i) => {
                  dc.current.innerHTML = newValue[i];
                  dc.current.style.top = "0";
                  dc.current.style.opacity = "1";
                });
              } else if (previousValues[unit] !== values[unit]) {
                for (let i = 0; i < 2; i++) {
                  if (newValue[i] !== oldValue[i]) {
                    animation.updateDigit(
                      unitsContainer[unit].digits[i],
                      newValue[i],
                      oldValue[i]
                    );
                  }
                }
              }
              previousValues[unit] = values[unit];
            });
            setTimeout(updateCountdown, 1000);
          };
          let previousValues = {
            days: -1,
            hours: -1,
            minutes: -1,
            seconds: -1,
          };
          units.forEach((unit) => {
            const containers = this.countdown.querySelectorAll(
              `.nb-countdown__unit-container--${unit}`
            );
            if (containers.length > 0) {
              const container = containers[0];
              const digitContainers = container.querySelectorAll(
                ".nb-countdown__digit-container"
              );
              unitsContainer[unit] = {
                container,
                digits: Array.from(digitContainers).map((dc) => ({
                  current: dc.querySelector(".nb-countdown__current-value"),
                  next: dc.querySelector(".nb-countdown__next-value"),
                })),
              };
            }
          });
          updateCountdown();
        },
      };
      animation.animate();
    })();
  });
}
document.addEventListener("DOMContentLoaded", function (t) {
  document.fonts.ready.then(function () {
    bricksIsFrontend && next_countdown();
  });
});
